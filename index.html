<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>MimiPlayer Demo</title>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; background: #f0f0f0; }
        button { padding: 15px 30px; font-size: 1.2rem; cursor: pointer; border-radius: 8px; border: none; background: #4CAF50; color: white; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        button:active { transform: translateY(2px); box-shadow: none; }
        pre { background: #333; color: #fff; padding: 20px; border-radius: 5px; font-size: 0.8rem; overflow-x: auto; max-width: 90%; }
    </style>
</head>
<body>
    <h1>Mimi Player</h1>
	<a href="http://AruihaYoru.github.io/mimi/maker/index.html">こちらで作曲！</a>
    <button id="playBtn">.mimiを再生！</button>
    <p>.mimi データの中身:</p>
    <pre id="dataPreview"></pre>

    <script>
        /**
         * MimiPlayer - Music Instrument Minimal Interface Player
         */
        class MimiPlayer {
            constructor(fps = 24) {
                this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.audioCtx.createGain();
                this.masterGain.connect(this.audioCtx.destination);
                this.fps = fps;
                this.notes = [];
                this.activeNodes = new Set();
                this._noise = null;
            }

            get noiseBuffer() {
                if (!this._noise) {
                    const size = this.audioCtx.sampleRate * 2;
                    this._noise = this.audioCtx.createBuffer(1, size, this.audioCtx.sampleRate);
                    const d = this._noise.getChannelData(0);
                    for (let i = 0; i < size; i++) d[i] = Math.random() * 2 - 1;
                }
                return this._noise;
            }

            load(text) {
                this.notes = text.split(/\r?\n/)
                    .map(l => l.trim())
                    .filter(l => l && !l.startsWith('#'))
                    .map(line => {
                        const [t, p, len, st, v, pan] = line.split(',').map(s => parseInt(s.trim(), 16));
                        return { type: t, pitch: p, length: len, start: st, volume: v ?? 255, pan: pan ?? 128 };
                    })
                    .sort((a, b) => a.start - b.start);
            }

            play(startFrame = 0) {
                this.stop();
                if (this.audioCtx.state === 'suspended') this.audioCtx.resume();
                
                const now = this.audioCtx.currentTime;
                const frameTime = 1 / this.fps;

                this.notes.forEach(n => {
                    const end = n.start + n.length;
                    if (end < startFrame) return;

                    const startTime = now + Math.max(0, (n.start - startFrame) * frameTime);
                    const duration = (n.start < startFrame ? end - startFrame : n.length) * frameTime;
                    
                    if (duration > 0) this.scheduleNote(n, startTime, duration);
                });
            }

            stop() {
                this.activeNodes.forEach(n => { try { n.stop(); } catch(e) {} });
                this.activeNodes.clear();
            }

            scheduleNote(note, startTime, duration) {
                const g = this.audioCtx.createGain();
                const p = this.audioCtx.createStereoPanner();
                let s;

                if (note.type === 4) {
                    s = this.audioCtx.createBufferSource();
                    s.buffer = this.noiseBuffer;
                    s.loop = true;
                } else {
                    s = this.audioCtx.createOscillator();
                    const types = ['sine', 'triangle', 'square', 'sawtooth'];
                    s.type = types[note.type] || 'sine';
                    s.frequency.value = 440 * Math.pow(2, (note.pitch - 69) / 12);
                }

                p.pan.value = (note.pan / 127.5) - 1;
                const vol = note.volume / 255;

                g.gain.setValueAtTime(0, startTime);
                g.gain.linearRampToValueAtTime(vol, startTime + 0.005);
                g.gain.setValueAtTime(vol, startTime + duration - 0.01);
                g.gain.linearRampToValueAtTime(0, startTime + duration);

                s.connect(g).connect(p).connect(this.masterGain);
                s.start(startTime);
                s.stop(startTime + duration);

                this.activeNodes.add(s);
                s.onended = () => this.activeNodes.delete(s);
            }
        }

        // --- ここからメイン処理 ---

        const mimiData = `
# Mimi Music Format v1.0
# Title: Midnight Cyber
# Tempo: 120BPM (1beat = 12frames / 1bar = 48frames)
# Type, Pitch, Length, Start, Volume, Pan

# --- BEAT (TYPE 04: Noise) ---
# Heavy Kick (1拍目・3拍目)
04, 10, 0004, 0000, FF, 80
04, 10, 0004, 0018, FF, 80
04, 10, 0004, 0030, FF, 80
04, 10, 0004, 0048, FF, 80

# Sharp Snare (2拍目・4拍目)
04, 30, 0002, 000C, C0, 80
04, 30, 0002, 0024, C0, 80
04, 30, 0002, 003C, C0, 80
04, 30, 0002, 0054, C0, 80

# --- BASS (TYPE 02: Square) ---
# シンプルで重いベースライン (D2 -> F2 -> G2 -> Bb2)
02, 26, 0006, 0000, A0, 80  # D2
02, 26, 0006, 000C, 80, 80  # D2
02, 29, 0006, 0018, A0, 80  # F2
02, 2B, 0006, 0024, A0, 80  # G2
02, 2E, 000C, 0030, A0, 80  # Bb2
02, 26, 0018, 0048, 90, 80  # D2 long

# --- ARP (TYPE 00: Sine) ---
# 背後で鳴る高速アルペジオ (右から左へ流れる)
00, 4A, 0003, 0000, 60, 20  # D5
00, 4D, 0003, 0003, 60, 40  # F5
00, 4F, 0003, 0006, 60, 60  # G5
00, 52, 0003, 0009, 60, 80  # Bb5
00, 4A, 0003, 000C, 60, A0  # D5
00, 4D, 0003, 000F, 60, C0  # F5
00, 4F, 0003, 0012, 60, E0  # G5
00, 52, 0003, 0015, 60, FF  # Bb5

# --- LEAD (TYPE 03: Sawtooth) ---
# 切ないリードメロディ
03, 3E, 0012, 0018, B0, 80  # D4
03, 41, 0006, 002A, B0, 80  # F4
03, 40, 0006, 0030, B0, 80  # E4
03, 3A, 0024, 0036, 80, 80  # Bb3
`;

        document.getElementById('dataPreview').textContent = mimiData.trim();

        const player = new MimiPlayer();
        player.load(mimiData);

        document.getElementById('playBtn').onclick = () => {
            player.play();
        };
    </script>
</body>
</html>

<!--

# MIMI Music Format v1.0 - Specification Test File
# Type, Pitch, Length, Start, Volume, Pan

# ---------------------------------------------------------
# TEST 1: 全波形チェック (0.5秒ずつ順番に鳴るはず)
# ---------------------------------------------------------
00, 45, 000C, 0000, FF, 80   # 0秒: 正弦波 (A4) - 中央
01, 45, 000C, 000C, FF, 80   # 0.5秒: 三角波 (A4) - 中央
02, 45, 000C, 0018, FF, 80   # 1.0秒: 矩形波 (A4) - 中央
03, 45, 000C, 0024, FF, 80   # 1.5秒: 鋸歯状波 (A4) - 中央
04, 00, 000C, 0030, FF, 80   # 2.0秒: ノイズ - 中央

# ---------------------------------------------------------
# TEST 2: パンニング（左右）チェック
# ---------------------------------------------------------
00, 3C, 0018, 0048, FF, 00   # 3.0秒: ド (左から)
00, 40, 0018, 0060, FF, FF   # 4.0秒: ミ (右から)
00, 43, 0018, 0078, FF, 80   # 5.0秒: ソ (真ん中から)

# ---------------------------------------------------------
# TEST 3: 和音とボリュームチェック (同時に重なる)
# ---------------------------------------------------------
01, 3C, 0030, 0090, 40, 40   # 6.0秒: 低音ド (音量控えめ、やや左)
01, 40, 0030, 0090, 40, C0   # 6.0秒: 低音ミ (音量控えめ、やや右)
01, 43, 0030, 0090, 40, 80   # 6.0秒: 低音ソ (音量控えめ、中央)

# ---------------------------------------------------------
# TEST 4: かき乱しテスト (一番最後にあるが、0秒地点で鳴るはず)
# ---------------------------------------------------------
03, 51, 00C0, 0000, 20, 80   # 0秒から最後まで鳴り続ける薄いベース音

# ---------------------------------------------------------
# TEST 5: 拡張列の無視テスト (7列目以降にゴミがあっても動くか)
# ---------------------------------------------------------
00, 48, 000C, 00C0, FF, 80, ERROR, 999, IGNORE_ME

-->