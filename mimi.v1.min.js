class MimiPlayerV1 {
    constructor(fps = 24) {
        this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        this.masterGain = this.audioCtx.createGain();
        this.masterGain.connect(this.audioCtx.destination);
        this.fps = fps;
        this.notes = [];
        this.activeNodes = new Set();
        this._noise = null;
    }

    get noiseBuffer() {
        if (!this._noise) {
            const size = this.audioCtx.sampleRate * 2;
            this._noise = this.audioCtx.createBuffer(1, size, this.audioCtx.sampleRate);
            const d = this._noise.getChannelData(0);
            for (let i = 0; i < size; i++) d[i] = Math.random() * 2 - 1;
        }
        return this._noise;
    }

    load(text) {
        this.notes = text.split(/\r?\n/)
            .map(l => l.split('#')[0].trim())
            .filter(l => l)
            .map(line => {
                const cols = line.split(',').map(s => s.trim());
                if (cols.length < 4) return null;
                return {
                    type:   parseInt(cols[0], 16),
                    pitch:  parseInt(cols[1], 16),
                    length: parseInt(cols[2], 16),
                    start:  parseInt(cols[3], 16),
                    volume: cols[4] !== undefined ? parseInt(cols[4], 16) : 255,
                    pan:    cols[5] !== undefined ? parseInt(cols[5], 16) : 128
                };
            })
            .filter(n => n !== null)
            .sort((a, b) => a.start - b.start);
    }

    play(startFrame = 0) {
        this.stop();
        if (this.audioCtx.state === 'suspended') this.audioCtx.resume();
        
        const now = this.audioCtx.currentTime;
        const frameTime = 1 / this.fps;

        this.notes.forEach(note => {
            const endFrame = note.start + note.length;
            if (endFrame < startFrame) return;

            const delay = Math.max(0, (note.start - startFrame) * frameTime);
            const startTime = now + delay;
            const duration = (note.start < startFrame ? endFrame - startFrame : note.length) * frameTime;
            
            if (duration > 0) {
                this.scheduleNote(note, startTime, duration);
            }
        });
    }

    stop() {
        this.activeNodes.forEach(n => { try { n.stop(); } catch(e) {} });
        this.activeNodes.clear();
    }

    scheduleNote(note, startTime, duration) {
        const g = this.audioCtx.createGain();
        const p = this.audioCtx.createStereoPanner();
        let s;

        if (note.type === 4) {
            s = this.audioCtx.createBufferSource();
            s.buffer = this.noiseBuffer;
            s.loop = true;
        } else {
            s = this.audioCtx.createOscillator();
            const types = ['sine', 'triangle', 'square', 'sawtooth'];
            s.type = types[note.type] || 'sine';
            const freq = 440 * Math.pow(2, (note.pitch - 69) / 12);
            s.frequency.setValueAtTime(freq, startTime);
        }

        p.pan.value = (note.pan / 127.5) - 1;

        const vol = note.volume / 255;
        const attack = 0.005;

        g.gain.setValueAtTime(0, startTime);
        g.gain.linearRampToValueAtTime(vol, startTime + attack);

        if (note.type === 4) {
            g.gain.exponentialRampToValueAtTime(0.001, startTime + duration);
        } else {
            const release = 0.01;
            g.gain.setValueAtTime(vol, startTime + duration - release);
            g.gain.linearRampToValueAtTime(0, startTime + duration);
        }

        s.connect(g).connect(p).connect(this.masterGain);
        s.start(startTime);
        s.stop(startTime + duration);

        this.activeNodes.add(s);
        s.onended = () => this.activeNodes.delete(s);
    }
}