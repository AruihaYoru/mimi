// 完成：2026/01/16 21:50

class MimiPlayerV2 {
    constructor(fps = 24) {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.fps = fps;
        this.notes = [];
        this.activeNodes = new Set();
        this.tempo = 120;
        this.masterGain = this.ctx.createGain();
        this.masterGain.connect(this.ctx.destination);
        
        if (typeof MimiHex !== 'undefined') {
            this.hexPlayer = new MimiHex(this.ctx);
            this.hexPlayer.output.connect(this.masterGain);
        } else {
            this.hexPlayer = null;
        }

        this._waveCache = {};
        console.log("( ˶ˆ꒳ˆ˵ ) Mimi-Engine v2.0 is waking up...");
    }

    _parseHeader(text) {
        const lines = text.split('\n');
        for (let line of lines) {
            if (!line.startsWith('#')) break;
            if (line.includes('Tempo:')) {
                const tMatch = line.match(/(\d+)/);
                if (tMatch) this.tempo = parseInt(tMatch[1], 10);
            }
        }
    }

    _parsePitch(p) {
        const freq = parseFloat(p);
        if (isNaN(freq)) return 440;
        return freq < 128 ? 440 * Math.pow(2, (freq - 69) / 12) : freq;
    }

	async load(text) {
		this.stop();
		this._parseHeader(text);
		this.notes = [];
		const lines = text.split('\n');

		for (const line of lines) {
			const trimmed = line.trim();
			if (!trimmed || trimmed.startsWith('#')) continue;

			const [main, slidePart] = trimmed.split(';').map(s => s.trim());
			const cols = main.split(',').map(s => s.trim());
			
			const type = parseInt(cols[0], 16);
			
			if (type === 0x0F && cols.length < 2) continue;
			if (type !== 0x0F && cols.length < 4) continue;
			
			if (/[^0-9a-fA-F,;.\-\s]/.test(main.split('#')[0])) {
				console.warn("(。•́ - •̀。) Mimi found a weird character...");
			}

			if (type === 0x0F) {
				if (!this.hexPlayer) continue;
				const hexData = cols.slice(2).join('').replace(/[^0-9a-fA-F]/g, '');
				const duration = hexData.length / 8000;
				
				this.notes.push({
					type: 0x0F,
					start: parseFloat(cols[1]),
					rawHex: cols.slice(2).join(''),
					len: duration
				});
			} else {
				this.notes.push({
					type: type,
					pitch: this._parsePitch(cols[1]),
					len: parseFloat(cols[2]),
					start: parseFloat(cols[3]),
					vol: cols[4] ? parseFloat(cols[4]) : 0.5,
					pan: cols[5] ? parseFloat(cols[5]) : 0.0,
					atk: cols[6] ? parseFloat(cols[6]) : 0.01,
					rel: cols[7] ? parseFloat(cols[7]) : 0.1,
					slide: slidePart ? parseFloat(slidePart) : 0
				});
			}
		}
		console.log("( *ˊᵕˋ)✩︎‧₊ Loading your project!");
	}

    _getNodeTime(time) {
        return this.ctx.currentTime + time;
    }
    
    _createPeriodicWave(dutyCycle, name) {
        if (this._waveCache[name]) return this._waveCache[name];
        const n = 4096;
        const real = new Float32Array(n);
        const imag = new Float32Array(n);
        for (let i = 1; i < n; i++) {
            const sin = Math.sin(Math.PI * i * dutyCycle);
            if (sin !== 0) {
                imag[i] = (2 / (Math.PI * i)) * sin;
            }
        }
        const wave = this.ctx.createPeriodicWave(real, imag, { disableNormalization: false });
        this._waveCache[name] = wave;
        return wave;
    }

    _createNoiseBuffer(type, duration) {
        const len = this.ctx.sampleRate * duration;
        const buffer = this.ctx.createBuffer(1, len, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        let lastOut = 0;
        let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;

        for (let i = 0; i < len; i++) {
            switch (type) {
                case 0x04: // White
                    data[i] = Math.random() * 2 - 1;
                    break;
                case 0x05: // Pink
                    const white = Math.random() * 2 - 1;
                    b0 = 0.99886 * b0 + white * 0.0555179;
                    b1 = 0.99332 * b1 + white * 0.0750759;
                    b2 = 0.96900 * b2 + white * 0.1538520;
                    b3 = 0.86650 * b3 + white * 0.3104856;
                    b4 = 0.55000 * b4 + white * 0.5329522;
                    b5 = -0.7616 * b5 - white * 0.0168980;
                    data[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.11;
                    b6 = white * 0.115926;
                    break;
                case 0x06: // Brown
                    const r = Math.random() * 2 - 1;
                    data[i] = (lastOut + (0.02 * r)) / 1.02;
                    lastOut = data[i];
                    data[i] *= 3.5;
                    break;
            }
        }
        return buffer;
    }

    play(startFrame = 0) {
        if (this.ctx.state === 'suspended') this.ctx.resume();
        const frameDuration = 60 / (this.tempo * (this.fps / 6));
        const startTimeOffset = startFrame * (1 / this.fps);

		// console.log("=== Play Debug ===");
		// console.log("frameDuration:", frameDuration);
		// console.log("startTimeOffset:", startTimeOffset);
		// Note: このバグ（Mimi_hexが再生時間に加算されない）を解決するにあたって、奮闘していただいたClaude Opus 4.5を筆頭としたAIたちに、最大限の敬意と感謝を払います。
			
        this.notes.forEach(n => {
            const scheduledStart = this._getNodeTime(n.start * frameDuration - startTimeOffset);
            if (scheduledStart < this.ctx.currentTime) return;

            if (n.type === 0x0F) {
                if(this.hexPlayer.play(n.rawHex, scheduledStart) === null){
                    console.error("Mimi doesn't understand your Hex language! (>_<)");
                }
                return;
            }

            const source = this._createSource(n, scheduledStart);
            if (!source) return;

            const envelope = this._createEnvelope(n, scheduledStart);
            const panner = this.ctx.createStereoPanner();
            panner.pan.setValueAtTime(n.pan, scheduledStart);
            
            source.connect(envelope).connect(panner).connect(this.masterGain);
        });

        const totalDuration = Math.max(0, ...this.notes.map(n => (n.start * frameDuration) + (n.len || 0))) * 1000;
        setTimeout(() => console.log("( ˘ω˘ )zzZ Mimi is tired..."), totalDuration);
    }
    
    _createSource(n, start) {
        let source;
        const duration = n.len + n.rel;

        switch (n.type) {
            case 0x00: case 0x01: case 0x02: case 0x03:
                source = this.ctx.createOscillator();
                source.type = ['sine', 'triangle', 'square', 'sawtooth'][n.type];
                source.frequency.setValueAtTime(n.pitch, start);
                break;
            case 0x04: case 0x05: case 0x06:
                source = this.ctx.createBufferSource();
                source.buffer = this._createNoiseBuffer(n.type, duration);
                source.loop = true;
                break;
            case 0x07: source = this._createPulseOsc(n, 0.0625, start); break;
            case 0x08: source = this._createPulseOsc(n, 0.125, start); break;
            case 0x09: source = this._createPulseOsc(n, 0.25, start); break;
            case 0x0A: source = this._createFMSynth(n, 'growl', start); break;
            case 0x0B: source = this._createFMSynth(n, 'metallic', start); break;
            case 0x0C: source = this._createSuperSaw(n, start); break;
            case 0x0D: source = this._createShortNoise(n, start); break;
            case 0x0E: source = this._createPluck(n, start); break;
            default: return null;
        }

        if (n.slide > 0 && source.frequency) {
            source.frequency.linearRampToValueAtTime(this._parsePitch(n.pitch), start + n.slide);
        }

        if (typeof source.start === 'function') {
            source.start(start);
            source.stop(start + duration);
            this.activeNodes.add(source);
            source.onended = () => this.activeNodes.delete(source);
        }
        return source;
    }

    _createEnvelope(n, start) {
        const gain = this.ctx.createGain();
        const vol = Math.max(0, Math.min(1, n.vol));
        const atk = Math.max(0.001, n.atk);
        const rel = Math.max(0.001, n.rel);
        const len = Math.max(0, n.len);
        
        gain.gain.setValueAtTime(0, start);
        gain.gain.linearRampToValueAtTime(vol, start + atk);
        if (len > atk + rel) {
             gain.gain.setValueAtTime(vol, start + len - rel);
        }
        gain.gain.linearRampToValueAtTime(0, start + len);
        return gain;
    }
    
    _createPulseOsc(n, duty, start) {
        const osc = this.ctx.createOscillator();
        osc.setPeriodicWave(this._createPeriodicWave(duty, `pulse${duty*100}`));
        osc.frequency.setValueAtTime(n.pitch, start);
        return osc;
    }

    _createFMSynth(n, mode, start) {
        const carrier = this.ctx.createOscillator();
        const modulator = this.ctx.createOscillator();
        const modGain = this.ctx.createGain();
        
        const config = {
            growl: { modRatio: 0.5, modIndex: 1000 },
            metallic: { modRatio: 1.4, modIndex: 800 }
        }[mode];

        modulator.frequency.setValueAtTime(n.pitch * config.modRatio, start);
        modGain.gain.setValueAtTime(config.modIndex, start);
        carrier.frequency.setValueAtTime(n.pitch, start);

        modulator.connect(modGain).connect(carrier.frequency);
        modulator.start(start);
        modulator.stop(start + n.len + n.rel);
        this.activeNodes.add(modulator);
        return carrier;
    }
    
    _createSuperSaw(n, start) {
        const master = this.ctx.createGain();
        for (let i = 0; i < 7; i++) {
            const osc = this.ctx.createOscillator();
            osc.type = 'sawtooth';
            const detune = (i - 3) * 10;
            osc.frequency.setValueAtTime(n.pitch, start);
            osc.detune.setValueAtTime(detune, start);
            const gain = this.ctx.createGain();
            gain.gain.value = i === 3 ? 1.0 : 0.6;
            osc.connect(gain).connect(master);
            osc.start(start);
            osc.stop(start + n.len + n.rel);
            this.activeNodes.add(osc);
        }
        return master;
    }
    
    _createShortNoise(n, start) {
        const len = 16;
        const buffer = this.ctx.createBuffer(1, len, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < len; i++) data[i] = Math.random() * 2 - 1;
        const source = this.ctx.createBufferSource();
        source.buffer = buffer;
        source.loop = true;
        source.playbackRate.setValueAtTime(n.pitch / 220, start); // A2=220Hz as base
        return source;
    }
    
    _createPluck(n, start) {
        const dur = n.len, sr = this.ctx.sampleRate, N = Math.round(sr / n.pitch);
        const buf = this.ctx.createBuffer(1, sr * dur, sr), d = buf.getChannelData(0);
        let ring = Array.from({length: N}, () => Math.random() * 2 - 1);
        for (let i = 0; i < d.length; i++) {
            d[i] = ring[i % N];
            ring[i % N] = (ring[i % N] + ring[(i + 1) % N]) * 0.496;
        }
        const src = this.ctx.createBufferSource();
        src.buffer = buf;
        return src;
    }

    stop() {
        this.activeNodes.forEach(node => {
            try { node.stop(0); } catch (e) {}
            if (node.disconnect) node.disconnect();
        });
        this.activeNodes.clear();
        if (this.hexPlayer) this.hexPlayer.stop();
    }
}

