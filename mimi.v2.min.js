class MimiPlayerV2 {
    constructor(fps = 24) {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.fps = fps;
        this.notes = [];
        this.activeNodes = new Set();
        this.tempo = 120;
        this.version = "2.0";
        this.masterGain = this.ctx.createGain();
        this.masterGain.connect(this.ctx.destination);
        
        if (typeof MimiHex !== 'undefined') {
            this.hexPlayer = new MimiHex(this.ctx);
            this.hexPlayer.output.connect(this.masterGain);
        } else {
            this.hexPlayer = null;
        }
        this._waveCache = {};
        this._log("( ˶ˆ꒳ˆ˵ ) Mimi-Engine v2.3 (Fix Timer Bug) is ready.");
    }

    _log(msg) {
        const log = document.getElementById('consoleLog');
        if(log) {
            log.innerHTML += `<div>${msg}</div>`;
            log.scrollTop = log.scrollHeight;
        }
        console.log(msg);
    }

    _parseHeader(text) {
        const lines = text.split('\n');
        for (let line of lines) {
            if (!line.startsWith('#')) break;
            const vMatch = line.match(/Mimi Music Format v([\d.]+)/);
            if (vMatch) this.version = vMatch[1];
            if (line.includes('Tempo:')) {
                const tMatch = line.match(/(\d+)/);
                if (tMatch) this.tempo = parseInt(tMatch[1], 10);
            }
        }
    }

    _parsePitch(p) {
        const midiNote = parseInt(p, 16);
        if (isNaN(midiNote)) return 440;
        return 440 * Math.pow(2, (midiNote - 69) / 12);
    }

    async load(text) {
        this.stop();
        this._parseHeader(text);
        this.notes = [];
        const frameTime = 1.0 / this.fps;
        
        const isLegacy = this.version.startsWith("1");
        const defaultAtk = isLegacy ? 0.005 : 0.01;
        const defaultRel = isLegacy ? 0.01 : 0.1;

        this._log(`( *ˊᵕˋ) Loading as version ${this.version} (Legacy Mode: ${isLegacy})`);

        const lines = text.split('\n');
        for (const line of lines) {
            const trimmed = line.trim();
            if (!trimmed || trimmed.startsWith('#')) continue;

            const [main, slidePart] = trimmed.split(';').map(s => s.trim());
            const cols = main.split(',').map(s => s.trim());
            
            const type = parseInt(cols[0], 16);
            if (type === 0x0F && cols.length < 2) continue;
            if (type !== 0x0F && cols.length < 4) continue;

            if (type === 0x0F) {
                if (!this.hexPlayer) continue;
                const rawHex = cols.slice(2).join('').replace(/[^0-9a-fA-F]/g, '');
                const duration = rawHex.length / 8000;
                this.notes.push({
                    type: 0x0F,
                    start: parseInt(cols[1], 16) * frameTime,
                    rawHex: rawHex,
                    len: duration,
                    rel: 0
                });
            } else {
                this.notes.push({
                    type: type,
                    pitch: this._parsePitch(cols[1]),
                    len: parseInt(cols[2], 16) * frameTime,
                    start: parseInt(cols[3], 16) * frameTime,
                    vol: cols[4] !== undefined ? parseInt(cols[4], 16) / 255.0 : 1.0,
                    pan: cols[5] !== undefined ? (parseInt(cols[5], 16) / 127.5) - 1.0 : 0.0,
                    atk: cols[6] ? parseInt(cols[6], 16) * frameTime : defaultAtk,
                    rel: cols[7] ? parseInt(cols[7], 16) * frameTime : defaultRel,
                    slide: slidePart ? parseInt(slidePart, 16) * frameTime : 0
                });
            }
        }
        this._log(`( *ˊᵕˋ)✩︎‧₊ ${this.notes.length} notes loaded!`);
    }

    _getNodeTime(time) { return this.ctx.currentTime + time; }
    
    _createPeriodicWave(dutyCycle, name) {
        if (this._waveCache[name]) return this._waveCache[name];
        const n = 4096;
        const real = new Float32Array(n);
        const imag = new Float32Array(n);
        for (let i = 1; i < n; i++) {
            const sin = Math.sin(Math.PI * i * dutyCycle);
            if (sin !== 0) imag[i] = (2 / (Math.PI * i)) * sin;
        }
        const wave = this.ctx.createPeriodicWave(real, imag, { disableNormalization: false });
        this._waveCache[name] = wave;
        return wave;
    }

    _createNoiseBuffer(type, duration) {
        const len = Math.floor(this.ctx.sampleRate * Math.max(0.01, duration));
        const buffer = this.ctx.createBuffer(1, len, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        let lastOut = 0, b0=0, b1=0, b2=0, b3=0, b4=0, b5=0, b6=0;
        for (let i = 0; i < len; i++) {
            switch (type) {
                case 0x04: data[i] = Math.random() * 2 - 1; break;
                case 0x05: 
                    const w = Math.random() * 2 - 1;
                    b0 = 0.99886*b0+w*0.0555179; b1 = 0.99332*b1+w*0.0750759; b2 = 0.96900*b2+w*0.1538520;
                    b3 = 0.86650*b3+w*0.3104856; b4 = 0.55000*b4+w*0.5329522; b5 = -0.7616*b5-w*0.0168980;
                    data[i] = (b0+b1+b2+b3+b4+b5+b6+w*0.5362)*0.11; b6 = w*0.115926; break;
                case 0x06: 
                    const r = Math.random() * 2 - 1;
                    data[i] = (lastOut + (0.02 * r)) / 1.02; lastOut = data[i]; data[i] *= 3.5; break;
            }
        }
        return buffer;
    }
    
    play(startFrame = 0) {
        if (this.ctx.state === 'suspended') this.ctx.resume();
        const frameTime = 1.0 / this.fps;
        const startTimeOffset = startFrame * frameTime;

        this.notes.forEach(n => {
            const scheduledStart = this._getNodeTime(n.start - startTimeOffset);
            const duration = (n.start + n.len + (n.rel || 0)) - startTimeOffset;

            if (duration <= 0 || scheduledStart < this.ctx.currentTime) return;

            if (n.type === 0x0F) {
                // ■修正箇所: 戻り値(Node)をn.lenに代入しないように変更しました
                this.hexPlayer.play(n.rawHex, scheduledStart);
                return;
            }

            const source = this._createSource(n, scheduledStart);
            if (!source) return;

            const envelope = this._createEnvelope(n, scheduledStart);
            const panner = this.ctx.createStereoPanner();
            panner.pan.setValueAtTime(n.pan, scheduledStart);
            source.connect(envelope).connect(panner).connect(this.masterGain);
        });
        
        // ■修正箇所: タイマー計算を正確にし、NaNリスクを回避
        const songEndTime = Math.max(0, ...this.notes.map(n => n.start + n.len + (n.rel || 0)));
        const timeRemaining = (songEndTime - startTimeOffset) * 1000;
        
        if (this.endTimer) clearTimeout(this.endTimer);
        this.endTimer = setTimeout(() => {
            this._log("( ˘ω˘ )zzZ Playing finished.");
        }, Math.max(0, timeRemaining));
    }
    
    _createSource(n, start) {
        let source;
        const duration = Math.max(0.01, n.len + n.rel);
        switch (n.type) {
            case 0x00: case 0x01: case 0x02: case 0x03:
                source = this.ctx.createOscillator();
                source.type = ['sine', 'triangle', 'square', 'sawtooth'][n.type];
                source.frequency.setValueAtTime(n.pitch, start);
                break;
            case 0x04: case 0x05: case 0x06:
                source = this.ctx.createBufferSource();
                source.buffer = this._createNoiseBuffer(n.type, duration);
                source.loop = true;
                break;
            case 0x07: source = this._createPulseOsc(n, 0.0625, start); break;
            case 0x08: source = this._createPulseOsc(n, 0.125, start); break;
            case 0x09: source = this._createPulseOsc(n, 0.25, start); break;
            case 0x0A: source = this._createFMSynth(n, 'growl', start); break;
            case 0x0B: source = this._createFMSynth(n, 'metallic', start); break;
            case 0x0C: source = this._createSuperSaw(n, start); break;
            case 0x0D: source = this._createShortNoise(n, start); break;
            case 0x0E: source = this._createPluck(n, start); break;
            default: return null;
        }
        if (n.slide > 0 && source.frequency) {
            source.frequency.setValueAtTime(n.pitch, start);
            source.frequency.linearRampToValueAtTime(n.pitch, start + n.slide);
        }
        if (typeof source.start === 'function') {
            source.start(start);
            source.stop(start + duration);
            this.activeNodes.add(source);
            source.onended = () => this.activeNodes.delete(source);
        }
        return source;
    }

    _createEnvelope(n, start) {
        const gain = this.ctx.createGain();
        const vol = Math.max(0, Math.min(1, n.vol));
        const atk = Math.max(0.001, n.atk);
        const rel = Math.max(0.001, n.rel);
        const len = Math.max(0.001, n.len);
        gain.gain.setValueAtTime(0, start);
        gain.gain.linearRampToValueAtTime(vol, start + atk);
        if (len > atk) gain.gain.setValueAtTime(vol, start + len);
        gain.gain.linearRampToValueAtTime(0, start + len + rel);
        return gain;
    }
    
    _createPulseOsc(n, duty, start) {
        const osc = this.ctx.createOscillator();
        osc.setPeriodicWave(this._createPeriodicWave(duty, `pulse${duty*100}`));
        osc.frequency.setValueAtTime(n.pitch, start);
        return osc;
    }

    _createFMSynth(n, mode, start) {
        const carrier = this.ctx.createOscillator();
        const modulator = this.ctx.createOscillator();
        const modGain = this.ctx.createGain();
        const config = { growl: { modRatio: 0.5, modIndex: 1000 }, metallic: { modRatio: 1.4, modIndex: 800 } }[mode];
        modulator.frequency.setValueAtTime(n.pitch * config.modRatio, start);
        modGain.gain.setValueAtTime(config.modIndex, start);
        carrier.frequency.setValueAtTime(n.pitch, start);
        modulator.connect(modGain).connect(carrier.frequency);
        modulator.start(start);
        modulator.stop(start + n.len + n.rel);
        this.activeNodes.add(modulator);
        return carrier;
    }
    
    _createSuperSaw(n, start) {
        const master = this.ctx.createGain();
        for (let i = 0; i < 7; i++) {
            const osc = this.ctx.createOscillator();
            osc.type = 'sawtooth';
            const detune = (i - 3) * 10;
            osc.frequency.setValueAtTime(n.pitch, start);
            osc.detune.setValueAtTime(detune, start);
            const gain = this.ctx.createGain();
            gain.gain.value = i === 3 ? 1.0 : 0.6;
            osc.connect(gain).connect(master);
            osc.start(start);
            osc.stop(start + n.len + n.rel);
            this.activeNodes.add(osc);
        }
        return master;
    }
    
    _createShortNoise(n, start) {
        const len = 16;
        const buffer = this.ctx.createBuffer(1, len, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < len; i++) data[i] = Math.random() * 2 - 1;
        const source = this.ctx.createBufferSource();
        source.buffer = buffer;
        source.loop = true;
        source.playbackRate.setValueAtTime(n.pitch / 220, start);
        return source;
    }
    
    _createPluck(n, start) {
        const dur = Math.max(0.01, n.len + n.rel);
        const sr = this.ctx.sampleRate;
        const N = Math.round(sr / n.pitch);
        const buf = this.ctx.createBuffer(1, sr * dur, sr);
        const d = buf.getChannelData(0);
        let ring = Array.from({length: N}, () => Math.random() * 2 - 1);
        for (let i = 0; i < d.length; i++) {
            d[i] = ring[i % N];
            ring[i % N] = (ring[i % N] + ring[(i + 1) % N]) * 0.496;
        }
        const src = this.ctx.createBufferSource();
        src.buffer = buf;
        return src;
    }

    stop() {
        if (this.endTimer) clearTimeout(this.endTimer);
        this.activeNodes.forEach(node => {
            try { node.stop(0); } catch (e) {}
            if (node.disconnect) node.disconnect();
        });
        this.activeNodes.clear();
        if (this.hexPlayer) this.hexPlayer.stop();
    }
}